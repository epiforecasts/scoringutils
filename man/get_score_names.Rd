% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_-functions.R
\name{get_score_names}
\alias{get_score_names}
\title{Get Names Of The Scoring Rules That Were Used For Scoring}
\usage{
get_score_names(scores, error = FALSE)
}
\arguments{
\item{scores}{A data.table with an attribute \code{score_names}}

\item{error}{Throw an error if there is no attribute called \code{score_names}?
Default is FALSE.}
}
\value{
Character vector with the names of the scoring rules that were used
for scoring or \code{NULL} if no scores were computed previously.
}
\description{
When applying a scoring rule, (for example through \code{\link[=score]{score()}} or
\code{\link[=add_coverage]{add_coverage()}}, the names of the scoring rules become column names of the
resulting data.table. In addition, an attribute \code{score_names} will be
added to the output, holding the names of the scores as a vector.
This is done so that a function like \code{\link[=get_forecast_unit]{get_forecast_unit()}} can still
identify which columns are part of the forecast unit and which hold a score.

\code{get_score_names()} access and returns this attribute. If there is no
attribute, the function will return NULL. Users can control whether the
function should error instead via the \code{error} argument.

\code{get_socre_names()} also checks whether the names of the scores stored in
the attribute are column names of the data and will throw a warning if not.
This can happen if you rename columns after scoring. You can either run
\code{\link[=score]{score()}} again, specifying names for the scoring rules manually, or you
can update the attribute manually using
\code{attr(scores, "score_names") <- c("names", "of", "your", "scores")} (the
order does not matter).
}
\keyword{check-forecasts}
