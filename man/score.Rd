% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/score.R
\name{score}
\alias{score}
\alias{score.default}
\alias{score.scoringutils_binary}
\alias{score.scoringutils_point}
\alias{score.scoringutils_sample}
\alias{score.scoringutils_quantile}
\title{Evaluate forecasts in a data.frame format}
\usage{
score(data, ...)

\method{score}{default}(data, ...)

\method{score}{scoringutils_binary}(data, metrics = metrics_binary, ...)

\method{score}{scoringutils_point}(data, metrics = metrics_point, ...)

\method{score}{scoringutils_sample}(data, metrics = metrics_sample, ...)

\method{score}{scoringutils_quantile}(data, metrics = metrics_quantile, ...)
}
\arguments{
\item{data}{A data.frame or data.table with predicted and observed values.}

\item{...}{additional arguments}

\item{metrics}{A named list of scoring functions. Names will be used as
column names in the output. See \code{\link[=metrics_point]{metrics_point()}}, \code{\link[=metrics_binary]{metrics_binary()}},
\code{metrics_quantile()}, and \code{\link[=metrics_sample]{metrics_sample()}} for more information on the
default metrics used.}
}
\value{
A data.table with unsummarised scores. This will generally be
one score per forecast (as defined by the unit of a single forecast).

For quantile-based forecasts, one score per quantile will be returned
instead. This is done as scores can be computed and may be of interest
for individual quantiles. You can call \code{\link[=summarise_scores]{summarise_scores()}}) on the
unsummarised scores to obtain one score per forecast unit for quantile-based
forecasts.
}
\description{
\code{score()} applies a selection of scoring metrics to a data.frame
of forecasts. It is the workhorse of the \code{scoringutils} package.
\code{score()} is a generic that dispatches to different methods depending on the
class of the input data.

We recommend that users call \code{\link[=as_forecast]{as_forecast()}} prior to calling \code{score()} to
validate the input data and convert it to a forecast object (though
\code{score.default()} will do this if it hasn't happened before).
See below for more information on forecast types and input formats.
For additional help and examples, check out the \href{https://epiforecasts.io/scoringutils/articles/scoringutils.html}{Getting Started Vignette} as
well as the paper \href{https://arxiv.org/abs/2205.07090}{Evaluating Forecasts with scoringutils in R}.
}
\section{Forecast types and input format}{
Various different forecast types / forecast formats are supported. At the
moment, those are
\itemize{
\item point forecasts
\item binary forecasts ("soft binary classification")
\item Probabilistic forecasts in a quantile-based format (a forecast is
represented as a set of predictive quantiles)
\item Probabilistic forecasts in a sample-based format (a forecast is represented
as a set of predictive samples)
}

Forecast types are determined based on the columns present in the input data.

\emph{Point forecasts} require a column \code{observed} of type numeric and a column
\code{predicted} of type numeric.

\emph{Binary forecasts} require a column \code{observed} of type factor with exactly
two levels and a column \code{predicted} of type numeric with probabilities,
corresponding to the probability that \code{observed} is equal to the second
factor level. See details \link[=brier_score]{here} for more information.

\emph{Quantile-based forecasts} require a column \code{observed} of type numeric,
a column \code{predicted} of type numeric, and a column \code{quantile} of type numeric
with quantile-levels (between 0 and 1).

\emph{Sample-based forecasts} require a column \code{observed} of type numeric,
a column \code{predicted} of type numeric, and a column \code{sample_id} of type
numeric with sample indices.

For more information see the vignettes and the example data
(\link{example_quantile}, \link{example_continuous}, \link{example_integer},
\code{\link[=example_point]{example_point()}}, and \link{example_binary}).
}

\section{Forecast unit}{
In order to score forecasts, \code{scoringutils} needs to know which of the rows
of the data belong together and jointly form a single forecasts. This is
easy e.g. for point forecast, where there is one row per forecast. For
quantile or sample-based forecasts, however, there are multiple rows that
belong to single forecast.

The \emph{forecast unit} or \emph{unit of a single forecast} is then described by the
combination of columns that uniquely identify a single forecast.
For example, we could have forecasts made by different models in various
locations at different time points, each for several weeks into the future.
The forecast unit could then be described as
\code{forecast_unit = c("model", "location", "forecast_date", "forecast_horizon")}.
\code{scoringutils} automatically tries to determine the unit of a single
forecast. It uses all existing columns for this, which means that no columns
must be present that are unrelated to the forecast unit. As a very simplistic
example, if you had an additional row, "even", that is one if the row number
is even and zero otherwise, then this would mess up scoring as \code{scoringutils}
then thinks that this column was relevant in defining the forecast unit.

In order to avoid issues, we recommend using the function
\code{\link[=set_forecast_unit]{set_forecast_unit()}} to determine the forecast unit manually.
The function simply drops unneeded columns, while making sure that all
necessary, 'protected columns' like "predicted" or "observed" are retained.
}

\examples{
library(magrittr) # pipe operator
data.table::setDTthreads(1) # only needed to avoid issues on CRAN

validated <- as_forecast(example_quantile)
score(validated) \%>\%
  summarise_scores(by = c("model", "target_type"))

# set forecast unit manually (to avoid issues with scoringutils trying to
# determine the forecast unit automatically), check forecasts before scoring
example_quantile \%>\%
  set_forecast_unit(
    c("location", "target_end_date", "target_type", "horizon", "model")
  ) \%>\%
  as_forecast() \%>\%
  score()

# forecast formats with different metrics
\dontrun{
score(example_binary)
score(example_quantile)
score(example_point)
score(example_integer)
score(example_continuous)
}
}
\references{
Bosse NI, Gruson H, Cori A, van Leeuwen E, Funk S, Abbott S
(2022) Evaluating Forecasts with scoringutils in R.
\doi{10.48550/arXiv.2205.07090}
}
\author{
Nikos Bosse \email{nikosbosse@gmail.com}
}
