% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/metrics-binary.R
\name{brier_score}
\alias{brier_score}
\title{Brier Score}
\usage{
brier_score(observed, predicted)
}
\arguments{
\item{observed}{A factor of length n with exactly two levels, holding
the observed values.
The highest factor level is assumed to be the reference level. This means
that \code{predicted} represents the probability that the observed value is
equal to the highest factor level.}

\item{predicted}{A numeric vector of length n, holding probabilities.
Values represent the probability that the corresponding outcome is equal to
the highest level of the factor \code{observed}.}
}
\value{
A numeric value with the Brier Score, i.e. the mean squared
error of the given probability forecasts
}
\description{
Computes the Brier Score for probabilistic forecasts of binary outcomes.
}
\details{
The Brier score is a proper score rule that assesses the accuracy of
probabilistic binary predictions. The outcomes can be either 0 or 1,
the predictions must be a probability that the observed outcome will be 1.

The Brier Score is then computed as the mean squared error between the
probabilistic prediction and the observed outcome.

\deqn{
  \textrm{Brier\_Score} = \frac{1}{N} \sum_{t = 1}^{n} (\textrm{prediction}_t -
  \textrm{outcome}_t)^2
}{
  Brier_Score = 1/N sum_{t = 1}^{n} (prediction_t - outcome_t)Â²
}

The function requires users to provide observed values as a factor in order
to distinguish its input from the input format required for scoring point
forecasts. Internally, however, factors will be converted to numeric values.
A factor \verb{observed = factor(c(0, 1, 1, 0, 1)} with two levels (\code{0} and \code{1})
would internally be coerced to a numeric vector (in this case this would
result in the numeric vector c(1, 2, 2, 1, 1)). After subtracting 1, the
resulting vector (\code{c(0, 1, 1, 0)} in this case) is used for internal
calculations. All predictions are assumed represent the probability that the
outcome is equal of the highest factor level (in this case that the
outcome is equal to 1).

You could alternatively also provide a vector like
\code{observed = factor(c("a", "b", "b", "a"))} (with two levels, \code{a} and \code{b}),
which would result in exactly the same internal representation. Probabilities
then represent the probability that the outcome is equal to "b".
If you want your predictions to be probabilities that the outcome is "a",
then you could of course make \code{observed} a factor with levels swapped, i.e.
\code{observed = factor(c("a", "b", "b", "a"), levels = c("b", "a"))}
}
\examples{
observed <- factor(sample(c(0, 1), size = 30, replace = TRUE))
predicted <- runif(n = 30, min = 0, max = 1)

brier_score(observed, predicted)
}
\keyword{metric}
