% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/forecast.R
\name{assert_forecast}
\alias{assert_forecast}
\alias{assert_forecast.default}
\alias{assert_forecast.forecast_binary}
\alias{assert_forecast.forecast_point}
\alias{assert_forecast.forecast_quantile}
\alias{assert_forecast.forecast_sample}
\title{Assert that input is a forecast object and passes validations}
\usage{
assert_forecast(forecast, forecast_type = NULL, verbose = TRUE, ...)

\method{assert_forecast}{default}(forecast, forecast_type = NULL, verbose = TRUE, ...)

\method{assert_forecast}{forecast_binary}(forecast, forecast_type = NULL, verbose = TRUE, ...)

\method{assert_forecast}{forecast_point}(forecast, forecast_type = NULL, verbose = TRUE, ...)

\method{assert_forecast}{forecast_quantile}(forecast, forecast_type = NULL, verbose = TRUE, ...)

\method{assert_forecast}{forecast_sample}(forecast, forecast_type = NULL, verbose = TRUE, ...)
}
\arguments{
\item{forecast}{A forecast object (a validated data.table with predicted and
observed values, see \code{\link[=as_forecast]{as_forecast()}})}

\item{forecast_type}{(optional) The forecast type you expect the forecasts
to have. If the forecast type as determined by \code{scoringutils} based on the
input does not match this, an error will be thrown. If \code{NULL} (the
default), the forecast type will be inferred from the data.}

\item{verbose}{Logical. If \code{FALSE} (default is \code{TRUE}), no messages and
warnings will be created.}

\item{...}{Additional arguments}
}
\value{
Depending on the forecast type, an object of class
\code{forecast_binary}, \code{forecast_point}, \code{forecast_sample} or
\code{forecast_quantile}.
}
\description{
Methods for the different classes run \code{\link[=assert_forecast_generic]{assert_forecast_generic()}}, which performs
checks that are the same for all forecast types and then perform specific
checks for the specific forecast type.
}
\section{Forecast types and input formats}{
Various different forecast types / forecast formats are supported. At the
moment, those are:
\itemize{
\item point forecasts
\item binary forecasts ("soft binary classification")
\item Probabilistic forecasts in a quantile-based format (a forecast is
represented as a set of predictive quantiles)
\item Probabilistic forecasts in a sample-based format (a forecast is represented
as a set of predictive samples)
}

Forecast types are determined based on the columns present in the input data.
Here is an overview of the required format for each forecast type:
\if{html}{
  \out{<div style="text-align: left">}
  \figure{required-inputs.png}{options: style="width:750px;max-width:100\%;"}
  \out{</div>}
}
\if{latex}{
  \figure{required-inputs.png}
}

\emph{All forecast types} require a data.frame or similar with columns \code{observed}
\code{predicted}, and \code{model}.

\emph{Point forecasts} require a column \code{observed} of type numeric and a column
\code{predicted} of type numeric.

\emph{Binary forecasts} require a column \code{observed} of type factor with exactly
two levels and a column \code{predicted} of type numeric with probabilities,
corresponding to the probability that \code{observed} is equal to the second
factor level. See details \link[=brier_score]{here} for more information.

\emph{Quantile-based forecasts} require a column \code{observed} of type numeric,
a column \code{predicted} of type numeric, and a column \code{quantile_level} of type
numeric with quantile-levels (between 0 and 1).

\emph{Sample-based forecasts} require a column \code{observed} of type numeric,
a column \code{predicted} of type numeric, and a column \code{sample_id} of type
numeric with sample indices.

For more information see the vignettes and the example data
(\link{example_quantile}, \link{example_sample_continuous}, \link{example_sample_discrete},
\code{\link[=example_point]{example_point()}}, and \link{example_binary}).
}

\examples{
forecast <- as_forecast(example_binary)
assert_forecast(forecast)
}
\keyword{check-forecasts}
